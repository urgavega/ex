Тестовое приложение ЕХ.

Состоит из 3х частей:
1. API
2. GUI
3. DB

===================================================================

GUI
	Написано как SPA. Не требует вебсервера и дополнительных настроек (кроме api_url) или сборки.
	Может запускаться из любой папки.
	Расположено в папке gui.
	Использованы технологии: HTML, CSS, Bootstrap 4, JavaScript, Jquery, Jquery-UI, Lodash.

Настройка API URL: 
	1. Открыть файл js/app.js
	2. заменить в первой строчке параметр на актуальный URL API EX
		const gl_url_api = 'http://ex.test/api/';
		
=====================================================================
		
DB
	В корневой папке лежит дамп базы с заполнеными данными ex.sql
	
	Таблицы.
	1. currencies - Список валют, которые используются в системе с буквенными кодами ISO 4217
	2. currency_rates - Список обменных курсов для валяют к 1 USD
	3. users - пользователи
		Страну и Город, в идеале, нужно вынести в отдельные таблицы.
		Но для простоты пользователи их задают сами.
	4. wallets - кошельки
		Один пользователь может иметь несколько кошельков. В том числе в одной валюте.
	5. wallets_actions_log - лог операций с кошельками
	
	База и все таблицы созданы в кодировке UTF-8
	
	Для хранения денежных данных используются тип поля bigint.
	(Все денежные значения хранятся как целые числа. Минимальная ед - 1/100 (например, коп, цент и т.д.))
	Подробнее см. в алгоритмах.
	
	Таблицы имеют индексы.
	
	Таблицы не имеют foreign keys 
	(Я полагаю, что удалить кошелек или пользователя - запрещено. Задачи удаления не ставилось в ТЗ.
	Вместо этого пользователи и кошельки должны иметь поле isDeleted.
	Это поле будет признаком удаления.)
	
=====================================================================

API
	Написано на PHP 7.2 и фреймворк Laravel 5.7
	Выполнено в виде REST API.
	
	Енд-поиты API с описанием и примерами использования, можно найти в api/routes/api.php
	
	
	Классы.
	Все основные классы находятся в api/app/EX/
	
	api/app/EX/Currency.php
	Класс для работы с валютами.
		Имеет особый коэффициент coeff = 1000000.
			 Параметр, которые переводит котировки в целое число.
			 Соответственно котировки должны иметь не больше 6 знаков после запятой
			 Если бывают котировки более точные (я не нашел), то нужно увеличить этот параметр.
			 В идеале это нужно выносить в файл настроек
			 
			 
	api/app/EX/Logger.php
	Класс для сохранения истории операции с кошельками.
		
	
	api/app/EX/Reporter.php
	Класс для формирования отчета
	Имеет особый параметр limit
		Ограничение кол-ва записей в одном запросе
		В идеале это нужно выносить в файл настроек
		$this->limit = 5;
	
	
	api/app/EX/User.php
	Класс для работы с пользователями
	
	
	api/app/EX/Wallet.php
	Класс для работы с кошельками
			Имеет особый коэффициент coeff = 100.
			 Параметр, которые переводит деньги в целое число - мин единица: 1 коп.
			 Соответственно деньги должны иметь не больше 2 знаков после запятой. (подробно см. в алгоритмах)
			 В идеале это нужно выносить в файл настроек
			 
			 
==============================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
==============================================================================

Проблемы, Алгоритмы, Решения

1. Проблема хранения чисел с плавающей точкой (далее ЧПТ) в БД.

Для хранения ЧПТ в обычно используются FLOAT или DOUBLE. Это приводит к ошибке представления числа.
Дело в том, что в этих типах число представлено в виде сумм степеней с основанием 2. В то время как 
денежные суммы во всех прайсах и документах представляются в десятичной системе счисления. Большинство 
дробных чисел в десятичной системе счисления не имеют точного представления в виде конечной суммы степеней двойки.

Вместо них лучшe использовать представление числа на основе степеней с основанием 10 — decimal. Например, DECIMAL(19,4).

Однако, лучше использовать bigint. Как более гибкий вариант. Мы не будем зависеть от кол-ва знаков после запятой, если 
в будущем захотим увеличить их кол-во или использовать в качестве валют криптовалюты или другие типы платежных средств с 
более мелким делением, чем традиционные валюты.

В приложении используются коэффициент 100 для денег. То есть минимальная единица - 1 "копейка" или цент (далее по копейкой я буду понимать 1/100 единицы любой валюты)
float 100.22 -> bigint 10022

При таком подходе максимальаня погрешность будет 1 копейка. (Delta. Как с ней поступить? Это тоже проблема. Об этом ниже.)

Для увеличения точность можно увеличить коэффициент. Например, 10000 - т.е. 4 знака после запятой. 
(Как показывать такие суммы в отчетах? Это тоже проблема. 
Для обывателя с обычными операциями такие точности не нужны. Об этом ниже.)

Резюме: Используем BIGINT в базе для денег.
	
***	
	
2. Проблема хранения чисел с плавающей точкой (далее ЧПТ) в PHP.

FLOAT (REAL, DOUBLE) не подходит по той же причине, что и в БД.
Кроме того, рациональные числа, которые могут быть точно представлены в виде чисел с плавающей точкой с основанием 10, 
например, 0.1 или 0.7, не имеют точного внутреннего представления в качестве чисел с плавающей точкой с основанием 2, 
вне зависимости от размера мантиссы. 

Тип INT так же не подходит для хранения наших целых чисел денег, так как имеет макс 21.474.836.47 (на 32-битных системах), что может быть недостаточно.
На 64-битных системах max int = 9223372036854775807. Это уже достаточно, если быть уверенным, что приложение будет запущено в такой ОС.

Решение. Я использовал библиотек gmp и bcmath.
gmp - библиотека позаволяет работать с целыми числами произвольной длины. Все числа представляются в виде строк - string.
bcmath - для вычислений с произвольной точностью PHP предоставляет двоичный калькулятор, который поддерживает числа любого размера и точности, 
	вплоть до 2147483647 (или 0x7FFFFFFF) десятичных знаков, если хватит памяти, представленных в виде строк.

Резюме: Используем string для хранения и gmp или bcmath для математических операций.

***

3. Проблема погрешности при математических операциях

При математических операциях может появляться и накапливаться погрешность из-за ошибка округления.
Так как мы используем целые числа, то проблему представляет операция деления.
При которой будет появляться остаток от деления. (Delta. Как с ним поступить? Тот же вопрос, что и пп1. Это тоже проблема. Об этом ниже.)

Чтобы снизить влияние этого рода погрешности, нужно сначала производить все возможные операции умножения, а только потом деления.

***

4. Проблема низкой точности котировок.

На сайтах в интернете или сайтах банков, котировки валют имеют максимум 4 знака после запятой.
Например: RUR=66.2645 (к USD).
т.е. 100$ ==> 6626.45р или в нашем представлении 10000c ==> 662645к
соответственно 1,000,000$ ==> 66,264,500р или в нашем представлении 1,000,000,00c ==> 66,264,500,00к
Но, поскольку в котировке потеряны разряды после 4, то в последнем примере погрешность будет до 100,00к
 (Delta. Как с ним поступить? Тот же вопрос, что и пп1. Это тоже проблема. Об этом ниже.)
 
 Решение: увеличение точности котировок. Если это возможно.

***

5. Округление до копеек и погрешность клиента.

Пример:
При конвертации 1000RUB => 19.97CAD
Но на самом деле мы получили 19.97ххххххCAD, но отбросили Delta, так как клиенту мы показываем суммы до копеек.
Теперь клиент хочет вернуть 19.97CAD, но поскольку хвост утерян и клиент его не знает (и не хочет знать), то он вводит 19.97CAD.
19.97CAD => 999.46RUB
То есть 54коп потерялись.

Это большая проблема и были случаи, когда упорные граждане зарабатывали так деньги на большом кол-ве конвертаций.

Банки борятся с этим устанавливая лимит кол-ва конвертаций за период, лимит на мин сумму конвертации и отслеживание подозрительных операций.

Мы можем увеличить кол-ва знаков после запятой до 4 или 5.
Минус - для экзотических валют вроде боливра может не хватить длинны bigint в базе.
Минус - неудобное представление сумм для обычных клиентов. Но, для форекс-клиентов это будет удобно.

Эта погрешность тоже попадет в Delta.

***

6. Delta. Что это и что как с этим поступить.
Delta - это доли копейки, которые мы получили при округлениях. 
А приложении они сохраняются в лог каждой операции на кошельке.

Поступить с Delta можно следующим образом:
1. Округлять в меньшую или большую сторону от 0.5 и прибавлять к сумме клиента.
У банка таких операций может быть миллионы в день и по теории вероятности сумма всех таких округлений
должна стремиться к 0. Но это требует проверки.

2. Забирать у клиента эту Delta и сохранять её в базе.
В конце периода подсчитывать сумму этих дельт по каждой валюте и либо оставлять её банку, либо возвращать клиенту.
В рамках одного клиента это будет очень маленькая сумма. Поэтому я считаю, что ей можно принебречь. Или оставить на решение руководства банка.

В приложении реализован второй вариант.

***

7. Составные операции с БД
Есть методы, в которых производится серия последовательных операций с БД.
Во время такой операции пожет произойти ошибка. И тогда операция не будет выполнена полностью, а только частично.

Решение. Использование транзакций. При выбрасывании исключения в любом месте внутри транзакции, все операции с БД откатываются 
к началу транзакции.

***

8. Ошибки в программе.
При возникновении ошибок в программе или любом модуле Laravel, выбрасываются исключения разных видов.
Они обрабатываются в обработчике исключений Laraval.
И, в зависимотси от типа исключения, принимается решение о действиях.

Исключения типа ValidationException и EXErrorException преобразуются в JSON с полем errors и возвращаются пользователю (SPA).
Остальные исключения (на данный момент) являются фатальными и приводят к аварийному завершению приложения.
При этом данные отправляются в Sentry для изучения и решения проблемы.

***

9. Большие объемы данных в отчете.
В отчете могут содержаться большие объемы данных. Поэтому разбиваем их на страницы.

***

10. Сохранение отчета в CSV.
На данный момент в приложении формирование и сохранение отчета в CSV происходит на стороне клиента. Браузер постранично запрашивает данные с сервера.
Преобразует их порциями и в конце сохраняет как csv файл.
Плюс: всё происходит на стороне клиента и не нагружает сервер. Клиент получает файл сразу и быстро.

Минусы: Однако, при больших и очень больших объемах данных такой способ может существенно замедлить работу компьютера клиента
и даже "подвесить" браузер.

Решение: Таскер.
На сервере (возможно на выделеном и не одном) запущен Таскер. Клиент ставит запрос на формирование отчета.
Запрос сохраняется в очередь. Клиент отключается.
Таскер в порядке очереди доходит до запроса клиента и берет его в работу.
После того, как отчет CSV готов, Таскер архивирует его (например, gzip), сохраняет с уникальным именем (например MD5-hash) в папку на сервере.
Эта папка доступра через HTTP или FTP.
И сообщает клиенту ссылку на скачивание файла через емайл и личный кабинет пользователя.

Плюс: 	Сервер API не нагружается отчетами и другими подобными задачами.
		Таскеров может быть много и они могут быть на любых языках и платформах
		Клиент получает gzip - уменшает трафик
		Компьютер клиента не падает
Минусы:	Долго ждать отчет (не сразу).
		Намного сложнее реализация и развитие.
		Дороже.
		
		
		
Спасибо за внимание.

P.S. Возможно, я забыл осветить какой-то момент. Пожалуйста, спрашивайте.

urga.vega@gmail.com


 
